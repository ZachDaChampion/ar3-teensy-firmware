// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_COBOTMSGS_RESPONSE_H_
#define FLATBUFFERS_GENERATED_RESPONSE_COBOTMSGS_RESPONSE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "_errors_generated.h"

namespace CobotMsgs {
namespace Response {

struct Response;
struct ResponseBuilder;

struct Ack;
struct AckBuilder;

struct Error;
struct ErrorBuilder;

struct Done;
struct DoneBuilder;

struct Joints;
struct JointsBuilder;

struct JointsEntry;
struct JointsEntryBuilder;

enum ResponsePayload : uint8_t {
  ResponsePayload_NONE = 0,
  ResponsePayload_Ack = 1,
  ResponsePayload_Error = 2,
  ResponsePayload_Done = 3,
  ResponsePayload_Joints = 4,
  ResponsePayload_MIN = ResponsePayload_NONE,
  ResponsePayload_MAX = ResponsePayload_Joints
};

inline const ResponsePayload (&EnumValuesResponsePayload())[5] {
  static const ResponsePayload values[] = {
    ResponsePayload_NONE,
    ResponsePayload_Ack,
    ResponsePayload_Error,
    ResponsePayload_Done,
    ResponsePayload_Joints
  };
  return values;
}

inline const char * const *EnumNamesResponsePayload() {
  static const char * const names[6] = {
    "NONE",
    "Ack",
    "Error",
    "Done",
    "Joints",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponsePayload(ResponsePayload e) {
  if (::flatbuffers::IsOutRange(e, ResponsePayload_NONE, ResponsePayload_Joints)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponsePayload()[index];
}

template<typename T> struct ResponsePayloadTraits {
  static const ResponsePayload enum_value = ResponsePayload_NONE;
};

template<> struct ResponsePayloadTraits<CobotMsgs::Response::Ack> {
  static const ResponsePayload enum_value = ResponsePayload_Ack;
};

template<> struct ResponsePayloadTraits<CobotMsgs::Response::Error> {
  static const ResponsePayload enum_value = ResponsePayload_Error;
};

template<> struct ResponsePayloadTraits<CobotMsgs::Response::Done> {
  static const ResponsePayload enum_value = ResponsePayload_Done;
};

template<> struct ResponsePayloadTraits<CobotMsgs::Response::Joints> {
  static const ResponsePayload enum_value = ResponsePayload_Joints;
};

bool VerifyResponsePayload(::flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type);
bool VerifyResponsePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  uint32_t message_id() const {
    return GetField<uint32_t>(VT_MESSAGE_ID, 0);
  }
  CobotMsgs::Response::ResponsePayload payload_type() const {
    return static_cast<CobotMsgs::Response::ResponsePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const CobotMsgs::Response::Ack *payload_as_Ack() const {
    return payload_type() == CobotMsgs::Response::ResponsePayload_Ack ? static_cast<const CobotMsgs::Response::Ack *>(payload()) : nullptr;
  }
  const CobotMsgs::Response::Error *payload_as_Error() const {
    return payload_type() == CobotMsgs::Response::ResponsePayload_Error ? static_cast<const CobotMsgs::Response::Error *>(payload()) : nullptr;
  }
  const CobotMsgs::Response::Done *payload_as_Done() const {
    return payload_type() == CobotMsgs::Response::ResponsePayload_Done ? static_cast<const CobotMsgs::Response::Done *>(payload()) : nullptr;
  }
  const CobotMsgs::Response::Joints *payload_as_Joints() const {
    return payload_type() == CobotMsgs::Response::ResponsePayload_Joints ? static_cast<const CobotMsgs::Response::Joints *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyResponsePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CobotMsgs::Response::Ack *Response::payload_as<CobotMsgs::Response::Ack>() const {
  return payload_as_Ack();
}

template<> inline const CobotMsgs::Response::Error *Response::payload_as<CobotMsgs::Response::Error>() const {
  return payload_as_Error();
}

template<> inline const CobotMsgs::Response::Done *Response::payload_as<CobotMsgs::Response::Done>() const {
  return payload_as_Done();
}

template<> inline const CobotMsgs::Response::Joints *Response::payload_as<CobotMsgs::Response::Joints>() const {
  return payload_as_Joints();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_id(uint32_t message_id) {
    fbb_.AddElement<uint32_t>(Response::VT_MESSAGE_ID, message_id, 0);
  }
  void add_payload_type(CobotMsgs::Response::ResponsePayload payload_type) {
    fbb_.AddElement<uint8_t>(Response::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Response::VT_PAYLOAD, payload);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t message_id = 0,
    CobotMsgs::Response::ResponsePayload payload_type = CobotMsgs::Response::ResponsePayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_message_id(message_id);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  AckBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  CobotMsgs::ErrorCode error_code() const {
    return static_cast<CobotMsgs::ErrorCode>(GetField<int8_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ERROR_CODE, 1) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(CobotMsgs::ErrorCode error_code) {
    fbb_.AddElement<int8_t>(Error::VT_ERROR_CODE, static_cast<int8_t>(error_code), 0);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(Error::VT_ERROR_MESSAGE, error_message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CobotMsgs::ErrorCode error_code = CobotMsgs::ErrorCode_ERR_OTHER,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CobotMsgs::ErrorCode error_code = CobotMsgs::ErrorCode_ERR_OTHER,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return CobotMsgs::Response::CreateError(
      _fbb,
      error_code,
      error_message__);
}

struct Done FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoneBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DoneBuilder {
  typedef Done Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DoneBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Done> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Done>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Done> CreateDone(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DoneBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Joints FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JointsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>> *joints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>> *>(VT_JOINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JOINTS) &&
           verifier.VerifyVector(joints()) &&
           verifier.VerifyVectorOfTables(joints()) &&
           verifier.EndTable();
  }
};

struct JointsBuilder {
  typedef Joints Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_joints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>>> joints) {
    fbb_.AddOffset(Joints::VT_JOINTS, joints);
  }
  explicit JointsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Joints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Joints>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Joints> CreateJoints(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>>> joints = 0) {
  JointsBuilder builder_(_fbb);
  builder_.add_joints(joints);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Joints> CreateJointsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>> *joints = nullptr) {
  auto joints__ = joints ? _fbb.CreateVector<::flatbuffers::Offset<CobotMsgs::Response::JointsEntry>>(*joints) : 0;
  return CobotMsgs::Response::CreateJoints(
      _fbb,
      joints__);
}

struct JointsEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JointsEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINT_ID = 4,
    VT_ANGLE = 6
  };
  uint8_t joint_id() const {
    return GetField<uint8_t>(VT_JOINT_ID, 0);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_JOINT_ID, 1) &&
           VerifyField<float>(verifier, VT_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct JointsEntryBuilder {
  typedef JointsEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_joint_id(uint8_t joint_id) {
    fbb_.AddElement<uint8_t>(JointsEntry::VT_JOINT_ID, joint_id, 0);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(JointsEntry::VT_ANGLE, angle, 0.0f);
  }
  explicit JointsEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JointsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JointsEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JointsEntry> CreateJointsEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t joint_id = 0,
    float angle = 0.0f) {
  JointsEntryBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_joint_id(joint_id);
  return builder_.Finish();
}

inline bool VerifyResponsePayload(::flatbuffers::Verifier &verifier, const void *obj, ResponsePayload type) {
  switch (type) {
    case ResponsePayload_NONE: {
      return true;
    }
    case ResponsePayload_Ack: {
      auto ptr = reinterpret_cast<const CobotMsgs::Response::Ack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_Error: {
      auto ptr = reinterpret_cast<const CobotMsgs::Response::Error *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_Done: {
      auto ptr = reinterpret_cast<const CobotMsgs::Response::Done *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponsePayload_Joints: {
      auto ptr = reinterpret_cast<const CobotMsgs::Response::Joints *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponsePayload(
        verifier,  values->Get(i), types->GetEnum<ResponsePayload>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Response
}  // namespace CobotMsgs

#endif  // FLATBUFFERS_GENERATED_RESPONSE_COBOTMSGS_RESPONSE_H_
