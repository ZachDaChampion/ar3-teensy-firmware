// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REQUEST_COBOTMSGS_REQUEST_H_
#define FLATBUFFERS_GENERATED_REQUEST_COBOTMSGS_REQUEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "_log_generated.h"

namespace CobotMsgs {
namespace Request {

struct Request;
struct RequestBuilder;

struct Init;
struct InitBuilder;

struct Calibrate;
struct CalibrateBuilder;

struct Override;
struct OverrideBuilder;

struct OverrideEntry;

struct GetJoints;
struct GetJointsBuilder;

struct MoveTo;
struct MoveToBuilder;

struct MoveToEntry;

struct MoveSpeed;
struct MoveSpeedBuilder;

struct MoveSpeedEntry;

struct Stop;
struct StopBuilder;

struct GoHome;
struct GoHomeBuilder;

struct Reset;
struct ResetBuilder;

struct SetLogLevel;
struct SetLogLevelBuilder;

enum RequestPayload : uint8_t {
  RequestPayload_NONE = 0,
  RequestPayload_Init = 1,
  RequestPayload_Calibrate = 2,
  RequestPayload_Override = 3,
  RequestPayload_GetJoints = 4,
  RequestPayload_MoveTo = 5,
  RequestPayload_MoveSpeed = 6,
  RequestPayload_Stop = 7,
  RequestPayload_GoHome = 8,
  RequestPayload_Reset = 9,
  RequestPayload_SetLogLevel = 10,
  RequestPayload_MIN = RequestPayload_NONE,
  RequestPayload_MAX = RequestPayload_SetLogLevel
};

inline const RequestPayload (&EnumValuesRequestPayload())[11] {
  static const RequestPayload values[] = {
    RequestPayload_NONE,
    RequestPayload_Init,
    RequestPayload_Calibrate,
    RequestPayload_Override,
    RequestPayload_GetJoints,
    RequestPayload_MoveTo,
    RequestPayload_MoveSpeed,
    RequestPayload_Stop,
    RequestPayload_GoHome,
    RequestPayload_Reset,
    RequestPayload_SetLogLevel
  };
  return values;
}

inline const char * const *EnumNamesRequestPayload() {
  static const char * const names[12] = {
    "NONE",
    "Init",
    "Calibrate",
    "Override",
    "GetJoints",
    "MoveTo",
    "MoveSpeed",
    "Stop",
    "GoHome",
    "Reset",
    "SetLogLevel",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestPayload(RequestPayload e) {
  if (::flatbuffers::IsOutRange(e, RequestPayload_NONE, RequestPayload_SetLogLevel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestPayload()[index];
}

template<typename T> struct RequestPayloadTraits {
  static const RequestPayload enum_value = RequestPayload_NONE;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::Init> {
  static const RequestPayload enum_value = RequestPayload_Init;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::Calibrate> {
  static const RequestPayload enum_value = RequestPayload_Calibrate;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::Override> {
  static const RequestPayload enum_value = RequestPayload_Override;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::GetJoints> {
  static const RequestPayload enum_value = RequestPayload_GetJoints;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::MoveTo> {
  static const RequestPayload enum_value = RequestPayload_MoveTo;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::MoveSpeed> {
  static const RequestPayload enum_value = RequestPayload_MoveSpeed;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::Stop> {
  static const RequestPayload enum_value = RequestPayload_Stop;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::GoHome> {
  static const RequestPayload enum_value = RequestPayload_GoHome;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::Reset> {
  static const RequestPayload enum_value = RequestPayload_Reset;
};

template<> struct RequestPayloadTraits<CobotMsgs::Request::SetLogLevel> {
  static const RequestPayload enum_value = RequestPayload_SetLogLevel;
};

bool VerifyRequestPayload(::flatbuffers::Verifier &verifier, const void *obj, RequestPayload type);
bool VerifyRequestPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OverrideEntry FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t joint_id_;
  int8_t padding0__;  int16_t padding1__;
  float angle_;

 public:
  OverrideEntry()
      : joint_id_(0),
        padding0__(0),
        padding1__(0),
        angle_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  OverrideEntry(uint8_t _joint_id, float _angle)
      : joint_id_(::flatbuffers::EndianScalar(_joint_id)),
        padding0__(0),
        padding1__(0),
        angle_(::flatbuffers::EndianScalar(_angle)) {
    (void)padding0__;
    (void)padding1__;
  }
  uint8_t joint_id() const {
    return ::flatbuffers::EndianScalar(joint_id_);
  }
  float angle() const {
    return ::flatbuffers::EndianScalar(angle_);
  }
};
FLATBUFFERS_STRUCT_END(OverrideEntry, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MoveToEntry FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t joint_id_;
  int8_t padding0__;  int16_t padding1__;
  float angle_;
  float speed_;

 public:
  MoveToEntry()
      : joint_id_(0),
        padding0__(0),
        padding1__(0),
        angle_(0),
        speed_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  MoveToEntry(uint8_t _joint_id, float _angle, float _speed)
      : joint_id_(::flatbuffers::EndianScalar(_joint_id)),
        padding0__(0),
        padding1__(0),
        angle_(::flatbuffers::EndianScalar(_angle)),
        speed_(::flatbuffers::EndianScalar(_speed)) {
    (void)padding0__;
    (void)padding1__;
  }
  uint8_t joint_id() const {
    return ::flatbuffers::EndianScalar(joint_id_);
  }
  float angle() const {
    return ::flatbuffers::EndianScalar(angle_);
  }
  float speed() const {
    return ::flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(MoveToEntry, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MoveSpeedEntry FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t joint_id_;
  int8_t padding0__;  int16_t padding1__;
  float speed_;

 public:
  MoveSpeedEntry()
      : joint_id_(0),
        padding0__(0),
        padding1__(0),
        speed_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  MoveSpeedEntry(uint8_t _joint_id, float _speed)
      : joint_id_(::flatbuffers::EndianScalar(_joint_id)),
        padding0__(0),
        padding1__(0),
        speed_(::flatbuffers::EndianScalar(_speed)) {
    (void)padding0__;
    (void)padding1__;
  }
  uint8_t joint_id() const {
    return ::flatbuffers::EndianScalar(joint_id_);
  }
  float speed() const {
    return ::flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(MoveSpeedEntry, 8);

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  uint32_t message_id() const {
    return GetField<uint32_t>(VT_MESSAGE_ID, 0);
  }
  CobotMsgs::Request::RequestPayload payload_type() const {
    return static_cast<CobotMsgs::Request::RequestPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const CobotMsgs::Request::Init *payload_as_Init() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_Init ? static_cast<const CobotMsgs::Request::Init *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::Calibrate *payload_as_Calibrate() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_Calibrate ? static_cast<const CobotMsgs::Request::Calibrate *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::Override *payload_as_Override() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_Override ? static_cast<const CobotMsgs::Request::Override *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::GetJoints *payload_as_GetJoints() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_GetJoints ? static_cast<const CobotMsgs::Request::GetJoints *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::MoveTo *payload_as_MoveTo() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_MoveTo ? static_cast<const CobotMsgs::Request::MoveTo *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::MoveSpeed *payload_as_MoveSpeed() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_MoveSpeed ? static_cast<const CobotMsgs::Request::MoveSpeed *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::Stop *payload_as_Stop() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_Stop ? static_cast<const CobotMsgs::Request::Stop *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::GoHome *payload_as_GoHome() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_GoHome ? static_cast<const CobotMsgs::Request::GoHome *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::Reset *payload_as_Reset() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_Reset ? static_cast<const CobotMsgs::Request::Reset *>(payload()) : nullptr;
  }
  const CobotMsgs::Request::SetLogLevel *payload_as_SetLogLevel() const {
    return payload_type() == CobotMsgs::Request::RequestPayload_SetLogLevel ? static_cast<const CobotMsgs::Request::SetLogLevel *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyRequestPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CobotMsgs::Request::Init *Request::payload_as<CobotMsgs::Request::Init>() const {
  return payload_as_Init();
}

template<> inline const CobotMsgs::Request::Calibrate *Request::payload_as<CobotMsgs::Request::Calibrate>() const {
  return payload_as_Calibrate();
}

template<> inline const CobotMsgs::Request::Override *Request::payload_as<CobotMsgs::Request::Override>() const {
  return payload_as_Override();
}

template<> inline const CobotMsgs::Request::GetJoints *Request::payload_as<CobotMsgs::Request::GetJoints>() const {
  return payload_as_GetJoints();
}

template<> inline const CobotMsgs::Request::MoveTo *Request::payload_as<CobotMsgs::Request::MoveTo>() const {
  return payload_as_MoveTo();
}

template<> inline const CobotMsgs::Request::MoveSpeed *Request::payload_as<CobotMsgs::Request::MoveSpeed>() const {
  return payload_as_MoveSpeed();
}

template<> inline const CobotMsgs::Request::Stop *Request::payload_as<CobotMsgs::Request::Stop>() const {
  return payload_as_Stop();
}

template<> inline const CobotMsgs::Request::GoHome *Request::payload_as<CobotMsgs::Request::GoHome>() const {
  return payload_as_GoHome();
}

template<> inline const CobotMsgs::Request::Reset *Request::payload_as<CobotMsgs::Request::Reset>() const {
  return payload_as_Reset();
}

template<> inline const CobotMsgs::Request::SetLogLevel *Request::payload_as<CobotMsgs::Request::SetLogLevel>() const {
  return payload_as_SetLogLevel();
}

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_id(uint32_t message_id) {
    fbb_.AddElement<uint32_t>(Request::VT_MESSAGE_ID, message_id, 0);
  }
  void add_payload_type(CobotMsgs::Request::RequestPayload payload_type) {
    fbb_.AddElement<uint8_t>(Request::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Request::VT_PAYLOAD, payload);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t message_id = 0,
    CobotMsgs::Request::RequestPayload payload_type = CobotMsgs::Request::RequestPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_message_id(message_id);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct Init FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPECTED_FW_VERSION = 4
  };
  uint32_t expected_fw_version() const {
    return GetField<uint32_t>(VT_EXPECTED_FW_VERSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EXPECTED_FW_VERSION, 4) &&
           verifier.EndTable();
  }
};

struct InitBuilder {
  typedef Init Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_expected_fw_version(uint32_t expected_fw_version) {
    fbb_.AddElement<uint32_t>(Init::VT_EXPECTED_FW_VERSION, expected_fw_version, 0);
  }
  explicit InitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Init> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Init>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Init> CreateInit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t expected_fw_version = 0) {
  InitBuilder builder_(_fbb);
  builder_.add_expected_fw_version(expected_fw_version);
  return builder_.Finish();
}

struct Calibrate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalibrateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINTS_BITFIELD = 4
  };
  uint8_t joints_bitfield() const {
    return GetField<uint8_t>(VT_JOINTS_BITFIELD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_JOINTS_BITFIELD, 1) &&
           verifier.EndTable();
  }
};

struct CalibrateBuilder {
  typedef Calibrate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_joints_bitfield(uint8_t joints_bitfield) {
    fbb_.AddElement<uint8_t>(Calibrate::VT_JOINTS_BITFIELD, joints_bitfield, 0);
  }
  explicit CalibrateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Calibrate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Calibrate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Calibrate> CreateCalibrate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t joints_bitfield = 0) {
  CalibrateBuilder builder_(_fbb);
  builder_.add_joints_bitfield(joints_bitfield);
  return builder_.Finish();
}

struct Override FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OverrideBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const ::flatbuffers::Vector<const CobotMsgs::Request::OverrideEntry *> *entries() const {
    return GetPointer<const ::flatbuffers::Vector<const CobotMsgs::Request::OverrideEntry *> *>(VT_ENTRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.EndTable();
  }
};

struct OverrideBuilder {
  typedef Override Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::OverrideEntry *>> entries) {
    fbb_.AddOffset(Override::VT_ENTRIES, entries);
  }
  explicit OverrideBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Override> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Override>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Override> CreateOverride(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::OverrideEntry *>> entries = 0) {
  OverrideBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Override> CreateOverrideDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<CobotMsgs::Request::OverrideEntry> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfStructs<CobotMsgs::Request::OverrideEntry>(*entries) : 0;
  return CobotMsgs::Request::CreateOverride(
      _fbb,
      entries__);
}

struct GetJoints FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetJointsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetJointsBuilder {
  typedef GetJoints Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetJointsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetJoints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetJoints>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetJoints> CreateGetJoints(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetJointsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MoveTo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveToBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const ::flatbuffers::Vector<const CobotMsgs::Request::MoveToEntry *> *entries() const {
    return GetPointer<const ::flatbuffers::Vector<const CobotMsgs::Request::MoveToEntry *> *>(VT_ENTRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.EndTable();
  }
};

struct MoveToBuilder {
  typedef MoveTo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::MoveToEntry *>> entries) {
    fbb_.AddOffset(MoveTo::VT_ENTRIES, entries);
  }
  explicit MoveToBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveTo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveTo> CreateMoveTo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::MoveToEntry *>> entries = 0) {
  MoveToBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MoveTo> CreateMoveToDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<CobotMsgs::Request::MoveToEntry> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfStructs<CobotMsgs::Request::MoveToEntry>(*entries) : 0;
  return CobotMsgs::Request::CreateMoveTo(
      _fbb,
      entries__);
}

struct MoveSpeed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveSpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const ::flatbuffers::Vector<const CobotMsgs::Request::MoveSpeedEntry *> *entries() const {
    return GetPointer<const ::flatbuffers::Vector<const CobotMsgs::Request::MoveSpeedEntry *> *>(VT_ENTRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.EndTable();
  }
};

struct MoveSpeedBuilder {
  typedef MoveSpeed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::MoveSpeedEntry *>> entries) {
    fbb_.AddOffset(MoveSpeed::VT_ENTRIES, entries);
  }
  explicit MoveSpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveSpeed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveSpeed> CreateMoveSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const CobotMsgs::Request::MoveSpeedEntry *>> entries = 0) {
  MoveSpeedBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MoveSpeed> CreateMoveSpeedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<CobotMsgs::Request::MoveSpeedEntry> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfStructs<CobotMsgs::Request::MoveSpeedEntry>(*entries) : 0;
  return CobotMsgs::Request::CreateMoveSpeed(
      _fbb,
      entries__);
}

struct Stop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMMEDIATE = 4,
    VT_JOINTS_BITFIELD = 6
  };
  bool immediate() const {
    return GetField<uint8_t>(VT_IMMEDIATE, 0) != 0;
  }
  uint8_t joints_bitfield() const {
    return GetField<uint8_t>(VT_JOINTS_BITFIELD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMMEDIATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_JOINTS_BITFIELD, 1) &&
           verifier.EndTable();
  }
};

struct StopBuilder {
  typedef Stop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_immediate(bool immediate) {
    fbb_.AddElement<uint8_t>(Stop::VT_IMMEDIATE, static_cast<uint8_t>(immediate), 0);
  }
  void add_joints_bitfield(uint8_t joints_bitfield) {
    fbb_.AddElement<uint8_t>(Stop::VT_JOINTS_BITFIELD, joints_bitfield, 0);
  }
  explicit StopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stop> CreateStop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool immediate = false,
    uint8_t joints_bitfield = 0) {
  StopBuilder builder_(_fbb);
  builder_.add_joints_bitfield(joints_bitfield);
  builder_.add_immediate(immediate);
  return builder_.Finish();
}

struct GoHome FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoHomeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINTS_BITFIELD = 4
  };
  uint8_t joints_bitfield() const {
    return GetField<uint8_t>(VT_JOINTS_BITFIELD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_JOINTS_BITFIELD, 1) &&
           verifier.EndTable();
  }
};

struct GoHomeBuilder {
  typedef GoHome Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_joints_bitfield(uint8_t joints_bitfield) {
    fbb_.AddElement<uint8_t>(GoHome::VT_JOINTS_BITFIELD, joints_bitfield, 0);
  }
  explicit GoHomeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoHome> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoHome>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GoHome> CreateGoHome(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t joints_bitfield = 0) {
  GoHomeBuilder builder_(_fbb);
  builder_.add_joints_bitfield(joints_bitfield);
  return builder_.Finish();
}

struct Reset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetBuilder {
  typedef Reset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ResetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Reset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Reset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Reset> CreateReset(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ResetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetLogLevel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLogLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG_LEVEL = 4
  };
  CobotMsgs::LogLevel log_level() const {
    return static_cast<CobotMsgs::LogLevel>(GetField<int8_t>(VT_LOG_LEVEL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LOG_LEVEL, 1) &&
           verifier.EndTable();
  }
};

struct SetLogLevelBuilder {
  typedef SetLogLevel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_log_level(CobotMsgs::LogLevel log_level) {
    fbb_.AddElement<int8_t>(SetLogLevel::VT_LOG_LEVEL, static_cast<int8_t>(log_level), 0);
  }
  explicit SetLogLevelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLogLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLogLevel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLogLevel> CreateSetLogLevel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CobotMsgs::LogLevel log_level = CobotMsgs::LogLevel_DEBUG) {
  SetLogLevelBuilder builder_(_fbb);
  builder_.add_log_level(log_level);
  return builder_.Finish();
}

inline bool VerifyRequestPayload(::flatbuffers::Verifier &verifier, const void *obj, RequestPayload type) {
  switch (type) {
    case RequestPayload_NONE: {
      return true;
    }
    case RequestPayload_Init: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::Init *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_Calibrate: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::Calibrate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_Override: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::Override *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_GetJoints: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::GetJoints *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_MoveTo: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::MoveTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_MoveSpeed: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::MoveSpeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_Stop: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::Stop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_GoHome: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::GoHome *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_Reset: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::Reset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestPayload_SetLogLevel: {
      auto ptr = reinterpret_cast<const CobotMsgs::Request::SetLogLevel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestPayload(
        verifier,  values->Get(i), types->GetEnum<RequestPayload>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Request
}  // namespace CobotMsgs

#endif  // FLATBUFFERS_GENERATED_REQUEST_COBOTMSGS_REQUEST_H_
